/**
 * Scroll to top or bottom of the page.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function goTo(position) {
  window.scrollTo({
    top: position === 'bottom' ? document.body.scrollHeight : 0,
    behavior: 'smooth',
  });
}

/**
 * Assign users to an issue.
 */
function hiToAssignee(usernames) {
  const assigneeUsers = document.querySelector('input[name="assignee_ids"]');
  if (!assigneeUsers) return;
  const assigneeElement = assigneeUsers.closest('div');
  const availableUsers = Array.from(assigneeElement.querySelectorAll('.dropdown a.item:not(.checked) span.gt-ellipsis'));
  const assigneeDropdown = assigneeElement.querySelector('.dropdown');

  let found = false;
  for (const username of usernames) {
    const items = availableUsers.filter((el) => el.textContent === username).map((el) => el.closest('a.item'));
    for (const item of items) {
      item.click();
      found = true;
    }
  }

  if (!found) return;
  assigneeDropdown.dispatchEvent(new Event('click', {bubbles: false}));
}

/**
 * Auto-save drafts for markdown editors using localStorage.
 */
function autoSaveDraft() {
  // Auto-save drafts for markdown editors
  for (const textarea of document.querySelectorAll('textarea')) {
    const editorWrapper = textarea._giteaComboMarkdownEditor;
    if (!editorWrapper) break;
    const cm = editorWrapper.textarea;
    if (!cm) break;
    const form = textarea.closest('form');
    if (!form) break;

    const storageKey = `gitea-draft-${editorWrapper.textarea.id}`;
    const draft = localStorage.getItem(storageKey);
    if (draft) cm.value = draft;

    const defaultContent = cm.value.trim();
    cm.addEventListener('mouseout', () => {
      const content = cm.value.trim();
      if (content.length && content !== defaultContent) {
        localStorage.setItem(storageKey, cm.value);
      } else {
        localStorage.removeItem(storageKey);
      }

      if (content.length) {
        const firstLine = content.split('\n')[0].trim();
        if (firstLine.startsWith('Hi @') && !firstLine.endsWith(',')) {
          hiToAssignee(firstLine.slice(4).split(' ').map((u) => u.trim().replace(/^@/, '')));
        }
      }
    });

    form.addEventListener('submit', () => {
      localStorage.setItem('last-submitted-draft', storageKey);
    });
  }

  const lastSubmittedDraft = localStorage.getItem('last-submitted-draft');
  if (lastSubmittedDraft) {
    localStorage.removeItem(lastSubmittedDraft);
    localStorage.removeItem('last-submitted-draft');
  }
}

/**
 * Automatically react with "eyes" emoji when a comment comes into view.
 * This uses IntersectionObserver to detect when comment headers are fully visible.
 * It waits 3 seconds before adding the reaction to avoid accidental reactions.
 * It also checks if the reaction already exists to prevent duplicates.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 */
function eyesHandler() {
  const commentList = document.querySelector('.comment-list');
  if (!commentList) return;
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        observer.unobserve(entry.target);
        const eyes = entry.target.querySelector('a.emoji[data-tooltip-content="eyes"]');
        if (eyes) {
          const loginedUser = document.querySelector('#navbar .user-menu .header strong').textContent;
          const existEyesReaction = entry.target.querySelector(`.bottom-reactions a[data-reaction-content=eyes][title*=${loginedUser}]`);
          if (existEyesReaction?.title.split(',').map((s) => s.trim()).includes(loginedUser)) {
            return;
          }
          setTimeout(() => {
            eyes.click();
          }, 3000);
        }
      }
    }
  }, {
    root: null,
    rootMargin: '-20% 0px',
    threshold: 1,
  });

  const commentHeaders = commentList.querySelectorAll('.comment-container');
  for (const header of commentHeaders) {
    observer.observe(header);
  }
}

/**
 * Wait for the markdown editor to be ready.
 */
function waitForTextareaToBeReady() {
  let attemptCount = 0;
  const MAX_ATTEMPTS = 30;
  const INTERVAL_MS = 100;

  const intervalId = setInterval(() => {
    const markdownEditor = document.querySelector('textarea')?._giteaComboMarkdownEditor;
    attemptCount++;

    if (markdownEditor) {
      clearInterval(intervalId);
      autoSaveDraft();
      eyesHandler();
    } else if (attemptCount >= MAX_ATTEMPTS) {
      clearInterval(intervalId);
    }
  }, INTERVAL_MS);
}

function watchAnnouncementsRepos() {
  const announcementPath = '/ADM/ANN';
  const isAnnouncementPage = window.location.pathname.startsWith(announcementPath);

  if (isAnnouncementPage) {
    const unwatchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/unwatch"] button`);
    const watchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/watch"] button`);

    if (unwatchFormButtonElement) {
      unwatchFormButtonElement.disabled = true;
    }

    if (watchFormButtonElement) {
      watchFormButtonElement.click();
    }
  }
}

function addCommentCounter() {
  const commentLists = document.querySelectorAll('.comment-list .comment-header-left');
  if (!commentLists) return;

  for (const [index, commentHeader] of commentLists.entries()) {
    if (index === 0) continue; // Skip the first comment (issue description)
    const counterSpan = document.createElement('span');
    counterSpan.className = 'comment-counter';
    counterSpan.textContent = `#${index} `;
    commentHeader.prepend(counterSpan);
  }
}

function relationPRtoIssuesTitle() {
  if (!document.querySelector('.pullrequest-form')) return;
  const comparePos = location.pathname.indexOf('/compare/');
  if (comparePos === -1) return;
  const reposName = location.pathname.substring(1, comparePos);
  if (!reposName) return;
  let branchName = location.pathname.substring(location.pathname.indexOf('...') + 3, location.pathname.length);
  if (branchName) {
    branchName = branchName.replace(/%23/g, '#');
    const regex = /_(\w+\/[\w-]+)[_#](\d+)$/;
    const branchNameAndID = regex.exec(branchName);
    if (branchNameAndID?.length > 2) {
      const mergeReposName = branchNameAndID[1];
      const mergeIssueID = branchNameAndID[2];
      fetch(`/api/v1/repos/${mergeReposName}/issues/${mergeIssueID}`).then(res => res.json()).then(data => {
        document.querySelector('#issue_title').value = `${data.title} ${mergeReposName}#${mergeIssueID}`;
      });
    }
  }
}

/**
 * Wait for the DOM to be ready.
 */
document.addEventListener('DOMContentLoaded', () => {
  waitForTextareaToBeReady();
  watchAnnouncementsRepos();
  addCommentCounter();
  relationPRtoIssuesTitle();
});
