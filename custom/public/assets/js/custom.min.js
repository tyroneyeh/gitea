class SimpleDB {
  constructor(storeName = 'items', ttl = 3600, dbName = 'gitea') {
    this.dbName = dbName;
    this.storeName = storeName;
    this.ttl = ttl; // seconds
    this.db = null;
  }

  async _openDB(version) {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.dbName, version);

      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, {keyPath: 'key'});
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async init() {
    if (this.db) return this.db;

    // 先開一次拿 version
    let version = 1;
    try {
      const tmp = await this._openDB();
      version = tmp.version;
      const hasStore = tmp.objectStoreNames.contains(this.storeName);
      tmp.close();
      if (!hasStore) version += 1;
    } catch {
      // 第一次建立 DB
    }

    this.db = await this._openDB(version);
    return this.db;
  }

  _isExpired(item) {
    if (!this.ttl) return false;
    return ((Date.now() / 1000) - item.createdAt) > this.ttl;
  }

  async get(key) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.get(key);

      req.onsuccess = () => {
        const item = req.result;
        if (!item) return resolve(null);

        if (this._isExpired(item)) {
          store.delete(key);
          resolve(null);
        } else {
          resolve(item.value);
        }
      };

      req.onerror = () => reject(req.error);
    });
  }

  async set(key, value) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);

      const req = store.put({
        key,
        value,
        createdAt: Date.now() / 1000,
      });

      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async remove(key) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.delete(key);

      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async clear() {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.clear();

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
}

/**
 * Scroll to top or bottom of the page.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function goTo(position) {
  window.scrollTo({
    top: position === 'bottom' ? document.body.scrollHeight : 0,
    behavior: 'smooth',
  });
}

function controlButtonsVisibility() {
  if (document.body.scrollHeight <= window.innerHeight) return;
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.target.id === 'navbar' && entry.isIntersecting) {
        document.querySelector('.gotocontrol.up').classList.add('tw-hidden');
        document.querySelector('.gotocontrol.down').classList.remove('tw-hidden');
      } else if (entry.target.id === '' && entry.isIntersecting) {
        document.querySelector('.gotocontrol.down').classList.add('tw-hidden');
        document.querySelector('.gotocontrol.up').classList.remove('tw-hidden');
      } else {
        if (window.scrollY > 0) document.querySelector('.gotocontrol.up').classList.remove('tw-hidden');
        document.querySelector('.gotocontrol.down').classList.remove('tw-hidden');
      }
    }
  }, {
    root: null,
    threshold: 0,
  });

  observer.observe(document.querySelector('#navbar'));
  observer.observe(document.querySelector('.page-footer'));
}

/**
 * Assign users to an issue.
 */
function hiToAssignee(usernames) {
  const assigneeUsers = document.querySelector('input[name="assignee_ids"]');
  if (!assigneeUsers) return;
  const assigneeElement = assigneeUsers.closest('div');
  const availableUsers = Array.from(assigneeElement.querySelectorAll('.dropdown a.item:not(.checked) span.gt-ellipsis'));
  const assigneeDropdown = assigneeElement.querySelector('.dropdown');

  let found = false;
  for (const username of usernames) {
    const items = availableUsers.filter((el) => el.title === username).map((el) => el.closest('a.item'));
    for (const item of items) {
      item.click();
      found = true;
    }
  }

  if (!found) return;
  assigneeDropdown.dispatchEvent(new Event('click', {bubbles: false}));
  assigneeDropdown.dispatchEvent(new Event('click', {bubbles: false}));
}

// auto select label #9
const _autoLabels = {
  'Solved': /^([Ff]ix|[Cc]ommit|[Mm]erge)([\w/ ]{4,}r\d{2,} [\da-f]{7,})/,
  'TestOK': /[Tt]est [Oo][Kk]\n/,
  'TestNG': /[Tt]est ([Ff]ail|NG)\n/,
  'NotTest': /[Nn]ot? [Tt]est\n/,
  'Tested': /[Tt]ested\n/,
};
const _titleLables = {
  'F2': ['f2 verify', 'f2 verification'],
  'Verification': ['verify', 'verification'],
  'ReleaseNote': ['release note'],
  'Wish': ['hope', 'wish'],
  'ADM': ['總務課'],
  'EWC': ['福委會'],
};
const _isolateLabels = {
  'TestNG': ['Solved', 'TestOK', 'Tested', 'NotTest'],
  'TestOK': ['TestNG', 'Tested', 'NotTest'],
  'Tested': ['TestNG', 'TestOK', 'NotTest'],
  'Solved': ['TestNG'],
};
function autoLabels(content) {
  const labelElement = document.querySelector('input[name=label_ids]');
  if (!labelElement) return;
  const availableLabelElements = Array.from(labelElement.closest('div').querySelectorAll('.menu a:not(.checked) span.gt-ellipsis'));

  for (const [label, pattern] of Object.entries(_autoLabels)) {
    if (pattern.test(content)) {
      const contentLabelElement = availableLabelElements.find((el) => el.textContent === label);
      if (contentLabelElement) {
        contentLabelElement.closest('a').dispatchEvent(new Event('click', {bubbles: true}));
        break;
      }
    }
  }

  const titleInputElement = document.querySelector('#issue_title');
  if (titleInputElement) {
    const titleLabelMatch = Object.keys(_titleLables).find((key) => _titleLables[key].some((k) => titleInputElement.value.toLowerCase().includes(k)));
    if (titleLabelMatch) {
      const titleLabelElement = availableLabelElements.find((el) => el.textContent === titleLabelMatch);
      if (titleLabelElement) {
        titleLabelElement.closest('a').dispatchEvent(new Event('click', {bubbles: true}));
      }
    }
    const deptLabelElement = availableLabelElements.find((el) => el.textContent === window.dept);
    if (deptLabelElement) {
      deptLabelElement.closest('a').dispatchEvent(new Event('click', {bubbles: true}));
      const labelDropdown = document.querySelector('input[name="label_ids"]').closest('div').querySelector('.dropdown');
      labelDropdown.dispatchEvent(new Event('click', {bubbles: false})); // for apply label
      labelDropdown.dispatchEvent(new Event('click', {bubbles: false})); // for hidden dropdown
    }
  }
}

/**
 * Auto-save drafts for markdown editors using localStorage.
 */
function autoSaveDraft() {
  // Auto-save drafts for markdown editors
  for (const textarea of document.querySelectorAll('textarea')) {
    const form = textarea.closest('form');
    if (!form) break;
    const isEasyMDE = localStorage.getItem('markdown-editor-comment') === 'easymde';

    const storageKey = textarea.id.replace(/^_combo_markdown_editor_/, '');
    const draft = localStorage.getItem(storageKey);
    if (draft) {
      if (isEasyMDE) {
        textarea._giteaComboMarkdownEditor?.easyMDE?.codemirror.setValue(draft);
      } else {
        textarea.value = draft;
      }
    }

    const defaultContent = textarea.value.trim();
    const doSave = () => {
      const content = textarea.value.trim();
      if (content.length && content !== defaultContent) {
        localStorage.setItem(storageKey, textarea.value);
      }

      if (content.length) {
        const firstLine = content.split('\n')[0].trim();
        if (firstLine.startsWith('Hi @') && !firstLine.endsWith(',')) {
          hiToAssignee(firstLine.slice(4).split(' ').map((u) => u.trim().replace(/^@/, '')));
        }

        autoLabels(content);
      } else {
        localStorage.removeItem(storageKey);
      }
    };

    if (isEasyMDE) {
      textarea._giteaComboMarkdownEditor?.easyMDE?.codemirror.on('blur', doSave);
    } else {
      textarea.addEventListener('mouseleave', doSave);
    }

    form.addEventListener('submit', () => {
      if (textarea.value.trim() === defaultContent) textarea.value = '';
      localStorage.setItem('last-submitted-draft', storageKey);
    });
  }

  const lastSubmittedDraft = localStorage.getItem('last-submitted-draft');
  if (lastSubmittedDraft) {
    localStorage.removeItem(lastSubmittedDraft);
    localStorage.removeItem('last-submitted-draft');
  }
}

/**
 * Automatically react with "eyes" emoji when a comment comes into view.
 * This uses IntersectionObserver to detect when comment headers are fully visible.
 * It waits 3 seconds before adding the reaction to avoid accidental reactions.
 * It also checks if the reaction already exists to prevent duplicates.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 */
function eyesHandler() {
  const commentList = document.querySelector('.comment-list');
  if (!commentList) return;
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        observer.unobserve(entry.target);
        const eyes = entry.target.querySelector('a.emoji[data-tooltip-content="eyes"]');
        if (eyes) {
          const existEyesReaction = entry.target.querySelector(`.bottom-reactions a[data-reaction-content=eyes][title*=${window.loginedUser}]`);
          if (existEyesReaction?.title.split(',').map((s) => s.trim()).includes(window.loginedUser)) {
            return;
          }
          setTimeout(() => {
            eyes.click();
          }, 3000);
        }
      }
    }
  }, {
    root: null,
    rootMargin: '-20% 0px',
    threshold: 1,
  });

  const commentHeaders = commentList.querySelectorAll('.comment-container');
  for (const header of commentHeaders) {
    observer.observe(header);
  }
}

/**
 * Wait for the markdown editor to be ready.
 */
function waitForTextareaToBeReady() {
  let attemptCount = 0;
  const MAX_ATTEMPTS = 30;
  const INTERVAL_MS = 100;

  const intervalId = setInterval(() => {
    const markdownEditor = document.querySelector('textarea')?._giteaComboMarkdownEditor;
    attemptCount++;

    if (markdownEditor) {
      clearInterval(intervalId);
      autoSaveDraft();
      eyesHandler();
    } else if (attemptCount >= MAX_ATTEMPTS) {
      clearInterval(intervalId);
    }
  }, INTERVAL_MS);
}

function watchAnnouncementsRepos() {
  const announcementPath = '/ADM/ANN';
  const isAnnouncementPage = window.location.pathname.startsWith(announcementPath);

  if (isAnnouncementPage) {
    const unwatchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/unwatch"] button`);
    const watchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/watch"] button`);

    if (unwatchFormButtonElement) {
      unwatchFormButtonElement.disabled = true;
    }

    if (watchFormButtonElement) {
      watchFormButtonElement.click();
    }
  }
}

function addCommentCounter() {
  const commentLists = document.querySelectorAll('.comment-list .comment-header-left');
  if (!commentLists) return;

  for (const [index, commentHeader] of commentLists.entries()) {
    if (index === 0) continue; // Skip the first comment (issue description)
    const counterSpan = document.createElement('span');
    counterSpan.className = 'comment-counter';
    counterSpan.textContent = `#${index} `;
    commentHeader.prepend(counterSpan);
  }
}

function relationPRtoIssuesTitle() {
  if (!document.querySelector('.pullrequest-form')) return;
  const comparePos = location.pathname.indexOf('/compare/');
  if (comparePos === -1) return;
  const reposName = location.pathname.substring(1, comparePos);
  if (!reposName) return;
  const branchNameWithID = location.pathname.substring(location.pathname.indexOf('...') + 3, location.pathname.length).replace(/%23/g, '#');
  const branchNameAndRepoAndIDMatch = /^(\w+)_.*_([\w/-]+)[_#](\d+)$/.exec(branchNameWithID);
  const branchNameAndIDMatch = /^(\w+)_.*_#?(\d+)$/.exec(branchNameWithID);
  const issueRepoAndIDMatch = /_([\w/-]+)[_#](\d+)$/.exec(branchNameWithID);
  const issueIDOnlyMatch = /[_#](\d+)$/.exec(branchNameWithID);
  const issueTitleInput = document.querySelector('#issue_title');
  const markdownEditor = document.querySelector('.markdown-text-editor');

  const fetchIssueDetails = async (mergeReposName, mergeIssueID) => {
    // eslint-disable-next-line no-restricted-syntax
    const response = await fetch(`/api/v1/repos/${mergeReposName}/issues/${mergeIssueID}`);
    if (!response.ok) return;
    const issueData = await response.json();
    const gid = reposName === mergeReposName ? `#${mergeIssueID}` : `${mergeReposName}#${mergeIssueID}`;
    issueTitleInput.value = `${issueData.title} ${gid}`;
    markdownEditor.value = markdownEditor.value.replace(/Issue ID:/, `Issue ID: ${gid}`);
    const commitSummary = Array.from(document.querySelectorAll('.commit-summary'), (v) => v.textContent).reverse();
    markdownEditor.value = markdownEditor.value.replace(/Description:\n -/, `Description:\n- ${commitSummary.join('\n - ')}`);
  };

  function selectedBranchName(branchName) {
    const branchWithoutRepo = location.pathname.substring(location.pathname.indexOf('/compare/') + 9);
    if (!branchWithoutRepo.startsWith(branchName)) {
      const matchBranch = Array.from(document.querySelectorAll('.base-branch-list a')).find((el) => el.textContent.endsWith(branchName));
      if (matchBranch) {
        const threeDotPos = branchWithoutRepo.indexOf('...');
        location = new URL(location.href.replace(branchWithoutRepo.substring(0, threeDotPos), branchName));
      }
    }
  }

  if (branchNameAndRepoAndIDMatch?.length > 3) {
    selectedBranchName(branchNameAndRepoAndIDMatch[2]);
    fetchIssueDetails(branchNameAndRepoAndIDMatch[2], branchNameAndRepoAndIDMatch[3]);
  } else if (branchNameAndIDMatch?.length > 2) {
    selectedBranchName(branchNameAndIDMatch[1]);
    fetchIssueDetails(reposName, branchNameAndIDMatch[2]);
  } else if (issueRepoAndIDMatch?.length > 2) {
    fetchIssueDetails(issueRepoAndIDMatch[1], issueRepoAndIDMatch[2]);
  } else if (issueIDOnlyMatch?.length > 1) {
    fetchIssueDetails(reposName, issueIDOnlyMatch[1]);
  }
}

const loadResource = (url, callback) => {
  if (document.querySelector(`script[src="${url}"]`) || document.querySelector(`link[href="${url}"]`)) {
    return;
  }
  const type = url.endsWith('.css') ? 'css' : 'js';
  const element = document.createElement(type === 'css' ? 'link' : 'script');
  if (type === 'css') {
    element.rel = 'stylesheet';
    element.href = url;
  } else {
    element.src = url;
    element.defer = true;
  }

  element.addEventListener('load', () => {
    // eslint-disable-next-line no-unused-expressions
    callback && callback();
  });

  if (type === 'css') {
    document.head.append(element);
  } else {
    document.body.append(element);
  }
};

function reportGenerator() {
  document.querySelector('.page-content').classList.add('tw-hidden');
  document.querySelector('#report').classList.remove('tw-hidden');

  loadResource('https://cdn.jsdelivr.net/npm/gridjs/dist/theme/mermaid.min.css');

  loadResource('https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js', () => {
    // eslint-disable-next-line no-undef
    const {createApp} = Vue;

    function daysBefore(n) {
      const date = new Date();
      date.setDate(date.getDate() - n);
      return date.toISOString().slice(0, 10);
    }

    window.app = createApp({
      delimiters: ['[[', ']]'],
      data() {
        return {
          orig: '',
          startDate: daysBefore(7),
          endDate: daysBefore(0),
          endDateMax: daysBefore(0),
          by: window.isRD ? 'assigned_by' : 'created_by',
          type: 'all',
          state: 'open',
          labels: '',
          q: '',
          username: window.loginedUser,
          assignees: [],
        };
      },
      watch: {
        startDate(newValue) {
          const newDay = new Date(newValue);
          newDay.setDate(newDay.getDate() + 7);
          if (newDay > new Date(this.endDate)) return;
          this.endDate = newDay.toISOString().slice(0, 10);
        },
        endDate(newValue) {
          const newDay = new Date(newValue);
          if (new Date(this.startDate) < newDay) return;
          newDay.setDate(newDay.getDate() - 7);
          this.startDate = newDay.toISOString().slice(0, 10);
        },
      },
      methods: {
        async queryReport() {
          const params = new URLSearchParams();
          params.set('state', this.state);
          params.set('since', `${this.startDate}T00:00:00Z`);
          params.set('before', `${this.endDate}T23:59:59Z`);

          if (this.orig) params.set('owner', this.orig);
          if (this.labels) params.set('labels', this.labels);
          if (this.q) params.set('q', this.q);

          const db = new SimpleDB('reportissue', this.endDate < daysBefore(0) ? 0 : 3600);

          let resData = await db.get(params.toString());

          if (!resData) {
            const url = `/api/v1/repos/issues/search?${params.toString()}`;
            // eslint-disable-next-line no-restricted-syntax
            const response = await fetch(url);
            if (response.ok) {
              resData = await response.json();
              db.set(params.toString(), resData);
            }
          }
          const data = [];
          let i = 1;
          for (const issue of resData) {
            if ((this.username && (this.by !== 'all' && this.by === 'assigned_by' && !issue.assignees?.filter((a) => a.username === this.username)) ||
              (this.by !== 'all' && this.by === 'created_by' && issue.user.username !== this.username)) ||
              (this.type !== 'all' && this.type !== (issue.pull_request ? 'pr' : 'issue')) ||
              (this.state !== 'all' && this.state !== issue.state)) continue;

            const labels = issue.labels.map((l) => l.name);
            const labelColors = issue.labels.map((l) => l.color);
            let label = '';
            for (let j = 0; j < labels.length; j++) {
              // eslint-disable-next-line github/unescaped-html-literal
              label += `<span style="color:#${labelColors[j]}">${labels[j]}</span> `;
            }

            const checked = issue.body.match(/- \[x\] /g)?.length || 0;
            const total = checked + (issue.body.match(/- \[ \] /g)?.length || 0);
            const pct = total > 0 ? Math.round(checked / total * 100) : 0;

            // eslint-disable-next-line github/unescaped-html-literal
            const title = `<a href="${issue.html_url}" target="_blank" rel="noopener">${issue.title}</a>`;

            // eslint-disable-next-line no-undef
            data.push([`${i++}.`, issue.pull_request ? 'PR' : 'Issue', issue.user.username, issue.assignees?.map((a) => a.username).join(', '), `${issue.repository.full_name}#${issue.number}`, gridjs.html(title), gridjs.html(label), issue.state, issue.created_at.slice(0, 10), issue.updated_at.slice(0, 10), `${pct}%`, issue.due_date ? issue.due_date.slice(0, 10) : '']);

            if (!this.assignees.length) this.assignees.push(...issue.assignees.map((a) => {return {username: a.username, avatar_url: a.avatar_url}}));
          }
          window.grid.updateConfig({
            data,
          }).forceRender();

          const exportBtn = document.createElement('input');
          exportBtn.type = 'button';
          exportBtn.value = 'Export';
          exportBtn.className = 'gridjs-input';
          document.querySelector('.gridjs-search').append(exportBtn);
          exportBtn.addEventListener('click', () => {
            // eslint-disable-next-line no-undef
            const tableExport = new TableExport(document.querySelector('.gridjs-table'), {formats: ['csv'], filename: `report-${this.endDate}`, position: 'top'});
            const exportData = tableExport.getExportData('csv')['tableexport-1']['csv'];
            tableExport.export2file(exportData.data,
              exportData.mimeType,
              exportData.filename,
              exportData.fileExtension,
              exportData.merges,
              exportData.RTL,
              exportData.sheetname);
          });
        },
        selectAssignee(assignee) {
          this.username = assignee;
        },
      },
      mounted() {
        loadResource('https://cdn.jsdelivr.net/npm/gridjs/dist/gridjs.umd.js', async () => {
          const columns = [
            {name: 'No.'},
            {name: 'Type', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Creator', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Assignee', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Repos.#ID', attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Title'},
            {name: 'Labels', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Status'},
            {name: 'Created At', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'Updated At', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
            {name: 'PCT', hidden: true, attributes: {style: 'white-space:nowrap'}},
            {name: 'Due Date', hidden: true, attributes: {style: 'white-space:nowrap;overflow:hidden'}},
          ];

          // eslint-disable-next-line no-undef
          window.grid = new gridjs.Grid({
            columns,
            data: [],
            sort: true,
            search: true,
          }).render(document.querySelector('#wrapper'));
          window.app.queryReport();

          for (const column of columns) {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `toggle-column-${column.name}`;
            checkbox.checked = !column.hidden;
            checkbox.addEventListener('change', (event) => {
              column.hidden = !event.target.checked;
              window.grid.updateConfig({
                columns,
              }).forceRender();
            });

            const label = document.createElement('label');
            label.htmlFor = `toggle-column-${column.name}`;
            label.innerHTML = ` ${column.name}&nbsp;&nbsp;`;

            const container = document.querySelector('#column-controls');
            container.append(checkbox);
            container.append(label);
            container.append(document.createTextNode(' '));
          }
        });
      },
    }).mount('#report');
  });
  loadResource('https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js');
  loadResource('https://cdn.jsdelivr.net/npm/tableexport/dist/js/tableexport.min.js');
}

function addReleaseFilterBar() {
  const newReleases = document.querySelector('.new.release form:not(.secondary-nav form)');
  if (newReleases) {
    newReleases.addEventListener('submit', async () => {
      const db = new SimpleDB('releases');
      await db.remove(location.pathname.replace(/\/new$/, ''));
    });
    return;
  }
  const wrapper = document.querySelector('#release-list');
  if (!wrapper) return;
  const filterBar = document.querySelector('#releaseFilterBar');
  filterBar.classList.remove('tw-hidden');
  wrapper.insertBefore(filterBar, wrapper.children[0]);
  loadResource('https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js', () => {
    // eslint-disable-next-line no-undef
    const {createApp} = Vue;
    createApp({
      delimiters: ['[[', ']]'],
      data() {
        return {
          releaselists: [],
        };
      },
      methods: {
        async queryRelease() {
          const db = new SimpleDB('releases');
          let data = await db.get(location.pathname);
          if (!data) {
            const reposName = location.pathname.substring(1, location.pathname.indexOf('/releases'));
            // eslint-disable-next-line no-restricted-syntax
            const response = await fetch(`/api/v1/repos/${reposName}/releases`);
            if (!response.ok) return;
            data = await response.json();
            db.set(location.pathname, data);
          }
          this.releaselists = data.map((v) => {return {name: v.name, html_url: v.html_url}});
          document.querySelector('#releaseFilterBar .filter').classList.add('visible');
        },
        selectRelease(html_url) {
          location = new URL(html_url);
        },
      },
    }).mount('#releaseFilterBar');
  });
}

/**
 * Wait for the DOM to be ready.
 */
document.addEventListener('DOMContentLoaded', () => {
  const userTitle = document.querySelector('.avatar').title;
  window.dept = userTitle.substring(0, userTitle.indexOf(' '));
  window.isRD = window.dept.startsWith('RD');
  window.loginedUser = document.querySelector('#navbar .user-menu .header strong').textContent;

  controlButtonsVisibility();
  waitForTextareaToBeReady();
  watchAnnouncementsRepos();
  addCommentCounter();
  relationPRtoIssuesTitle();
  if (location.hash === '#report') {
    reportGenerator();
  }
  if (location.pathname.includes('/releases')) {
    addReleaseFilterBar();
  }
});
