/* eslint-disable @eslint-community/eslint-comments/disable-enable-pair */
/* eslint-disable unicorn/prefer-add-event-listener */

/* eslint-disable github/no-dataset */
class SimpleDB {
  constructor(storeName = 'items', ttl = 3600, dbName = 'gitea') {
    this.dbName = dbName;
    this.storeName = storeName;
    this.ttl = ttl; // seconds
    this.db = null;
  }

  async _openDB(version) {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.dbName, version);

      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, {keyPath: 'key'});
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async init() {
    if (this.db) return this.db;

    let version = 1;
    try {
      const tmp = await this._openDB();
      version = tmp.version;
      const hasStore = tmp.objectStoreNames.contains(this.storeName);
      tmp.close();
      if (!hasStore) version += 1;
    } catch {}

    this.db = await this._openDB(version);
    return this.db;
  }

  _isExpired(item) {
    if (!this.ttl) return false;
    return ((Date.now() / 1000) - item.createdAt) > this.ttl;
  }

  async get(key) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.get(key);

      req.onsuccess = () => {
        const item = req.result;
        if (!item) return resolve(null);

        if (this._isExpired(item)) {
          store.delete(key);
          resolve(null);
        } else {
          resolve(item.value);
        }
      };

      req.onerror = () => reject(req.error);
    });
  }

  async set(key, value) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);

      const req = store.put({
        key,
        value,
        createdAt: Date.now() / 1000,
      });

      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async remove(key) {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.delete(key);

      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }

  async clear() {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.clear();

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  async getAllKeys() {
    const db = await this.init();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const req = store.getAllKeys();

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
}

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function setCursor(cursor) {
  document.body.style.cursor = cursor;
  const elements = document.querySelectorAll('input, textarea, button, select, label, div');

  for (const el of elements) {
    el.style.cursor = cursor;
  }
}

/**
 * Scroll to top or bottom of the page.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function goTo(position, e) {
  window.isProgrammaticScroll = true;
  window.scrollTo({
    top: position === 'bottom' ? Math.max(document.documentElement.scrollHeight, document.body.scrollHeight) : 0, // Legacy Firefox, IE and Opera require the max() workaround.document.body.scrollHeight : 0,
  });
  e.currentTarget.classList.add('tw-hidden');
}

function controlButtonsVisibility() {
  if (document.body.scrollHeight <= window.innerHeight) return;
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.target.classList.contains('container') && entry.isIntersecting) {
        document.querySelector('.gotocontrol.up').classList.add('tw-hidden');
        document.querySelector('.gotocontrol.down').classList.remove('tw-hidden');
      } else if (entry.target.classList.contains('page-footer') && entry.isIntersecting) {
        document.querySelector('.gotocontrol.down').classList.add('tw-hidden');
        document.querySelector('.gotocontrol.up').classList.remove('tw-hidden');
      } else {
        if (window.scrollY > 0) document.querySelector('.gotocontrol.up').classList.remove('tw-hidden');
        document.querySelector('.gotocontrol.down')?.classList.remove('tw-hidden');
      }
    }
  }, {
    root: null,
    threshold: 0,
  });

  observer.observe(document.querySelector('.container'));
  observer.observe(document.querySelector('.page-footer'));
}

function post(url, data) {
  // eslint-disable-next-line no-restricted-syntax
  return fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'X-Csrf-Token': window.config.csrfToken,
    },
    body: new URLSearchParams(data).toString(),
  });
}

async function get(url) {
  setCursor('wait');
  // eslint-disable-next-line no-restricted-syntax
  const response = await fetch(url, {
    headers: {
      'X-Csrf-Token': window.config.csrfToken,
    },
  });
  setCursor('');
  return response.ok ? response.json() : null;
}

/**
 * Assign users to an issue.
 */
function hiToAssignee(userNames) {
  const assigneeInput = document.querySelector('input[name="assignee_ids"]');
  if (!assigneeInput) return;
  window.assigneeElement = assigneeInput.closest('div');
  const availableUserElements = Array.from(window.assigneeElement.querySelectorAll('.dropdown a.item span.gt-ellipsis'), (el) => el.closest('a.item'));
  const isNewIssue = document.querySelector('#issue_title');
  window.assigneeIds = window.assigneeIds || [];

  for (const availableUserElement of availableUserElements) {
    const isChecked = userNames.includes(availableUserElement.querySelector('.gt-ellipsis').title);
    const assigneeData = {action: 'attach', id: availableUserElement.dataset.value};
    const checked = availableUserElement.classList.contains('checked');
    if (isNewIssue && checked !== isChecked) {
      window.assigneeElement = window.assigneeElement.querySelector('.dropdown');
      availableUserElement.click();
    } else if (checked !== isChecked && !window.assigneeIds.some((el) => el.action === assigneeData.action && el.id === assigneeData.id)) {
      window.assigneeIds.push(assigneeData);
    }
  }
}

// auto select label #9
const _autoLabels = {
  'Solved': /([Ff]ix|[Cc]ommit|[Mm]erge)([\w/ ]{4,}r\d{2,} [\da-f]{7,})/,
  'Test/OK': /[Tt]est [Oo][Kk]\n/,
  'Test/NG': /[Tt]est ([Ff]ail|[Nn][Gg])\n/,
  'TestOK': /[Tt]est [Oo][Kk]\n/,
  'TestNG': /[Tt]est ([Ff]ail|[Nn][Gg])\n/,
  'NotTest': /[Nn]ot? [Tt]est\n/,
  'Tested': /[Tt]ested\n/,
};
const _titleLables = {
  'F2': ['f2 verify', 'f2 verification'],
  'Verification': ['verify', 'verification'],
  'ReleaseNote': ['release note'],
  'Wish': ['hope', 'wish'],
  'ADM': ['總務課'],
  'EWC': ['福委會'],
};

async function autoLabels(content) {
  const labelInput = document.querySelector('input[name=label_ids]');
  if (!labelInput) return;
  window.labelElement = labelInput.closest('div');
  const availableLabelElements = Array.from(window.labelElement.querySelectorAll('.menu a.item:not(.checked) span.gt-ellipsis'));
  const titleInputElement = document.querySelector('#issue_title');

  window.labelIds = window.labelIds || [];
  for (const [label, pattern] of Object.entries(_autoLabels)) {
    if (pattern.test(content)) {
      const contentLabelElement = availableLabelElements.find((el) => el.textContent.trim() === label);
      if (contentLabelElement) {
        if (titleInputElement) window.labelElement = window.labelElement.querySelector('.dropdown');
        const lableData = {action: 'attach', id: contentLabelElement.closest('a').dataset.value};
        if (!window.labelIds.some((el) => el.action === lableData.action && el.id === lableData.id)) window.labelIds.push(lableData);
        break;
      }
    }
  }

  if (titleInputElement) {
    window.childLabelElements = window.childLabelElements || [];
    const titleLabelMatch = Object.keys(_titleLables).find((key) => _titleLables[key].some((k) => titleInputElement.value.toLowerCase().includes(k)));
    if (titleLabelMatch) {
      const titleLabelElement = availableLabelElements.find((el) => el.textContent.trim() === titleLabelMatch);
      if (titleLabelElement) {
        window.labelElement = window.labelElement.querySelector('.dropdown');
        window.childLabelElements.push(titleLabelElement);
      }
    }
    const deptLabelElement = availableLabelElements.find((el) => el.textContent.trim() === window.dept);
    if (deptLabelElement) {
      if (!window.labelElement) window.labelElement = window.labelElement.querySelector('.dropdown');
      window.childLabelElements.push(deptLabelElement);
    }
    const nowYear = new Date().getFullYear().toString();
    const milestoneYearElement = Array.from(document.querySelector('input[name=milestone_id]').closest('div').querySelectorAll('.menu a.item')).find((el) => el.textContent.trim() === nowYear);
    if (milestoneYearElement) milestoneYearElement.click();
  }
}

function getSaveDraftKey(textarea) {
    const pathName = location.pathname.replace(/\//g, '_').slice(1);
    return textarea.id.replace(/^_combo_markdown_editor_/, `${pathName}-`);
}

/**
 * Auto-save drafts for markdown editors using localStorage.
 */
function autoSaveDraft() {
  let isSaved = false;

  // Auto-save drafts for markdown editors
  for (const textarea of document.querySelectorAll('textarea')) {
    const form = textarea.closest('form');
    if (!form) break;
    const isEasyMDE = localStorage.getItem('markdown-editor-comment') === 'easymde';
    const signatureContent = document.querySelector('#signature')?.textContent || document.querySelector('#signature')?.content?.textContent || '';
    if (signatureContent !== '' && localStorage.getItem('user-signature') !== signatureContent) {
      localStorage.setItem('user-signature', signatureContent);
    }
    const draft = localStorage.getItem(getSaveDraftKey(textarea)) || signatureContent;
    if (draft) {
      if (isEasyMDE) {
        let retry = 0;
        const retryTimer = setInterval(() => {
          const editor = textarea._giteaComboMarkdownEditor?.easyMDE?.codemirror;
          if (!editor) {
            if (retry++ > 100) clearInterval(retryTimer);
            return;
          }
          clearInterval(retryTimer);
          if (editor.getValue() !== draft) {
            editor.setValue(editor.getValue() + draft);
          } else {
            editor.setValue(draft);
          }
        }, 50);
      } else {
        if (textarea.value !== draft) {
          textarea.value += draft;
        } else {
          textarea.value = draft;
        }
      }
    }

    const doSave = (eventType) => {
      const content = textarea.value.trim();
      const storageKey = getSaveDraftKey(textarea);
      if (content.length && content !== signatureContent.trim()) {
        localStorage.setItem(storageKey, textarea.value);
        isSaved = true;
      }

      if (content.length) {
        if (eventType !== 'mouseover') {
          if (content === signatureContent.trim()) {
            localStorage.removeItem(storageKey);
            isSaved = false;
          }
          return;
        }
        autoLabels(content);
        const isNewIssue = document.querySelector('#issue_title');
        if (isNewIssue && window.childLabelElements.length) {
          for (const childLabelElement of window.childLabelElements) {
            childLabelElement.click();
          }
          if (window.labelElement) {
            const labelA = window.labelElement.querySelector('a');
            labelA.click();
            labelA.click();
            delete window.childLabelElements;
          }
        }

        const firstLine = content.split('\n')[0].trim();
        if (firstLine.startsWith('Hi @') && !firstLine.endsWith(',')) {
          hiToAssignee(firstLine.slice(4).split(' ').map((u) => u.trim().replace(/^@/, '')));
          if (isNewIssue && window.assigneeElement) {
            const assigneeA = window.assigneeElement.querySelector('a');
            assigneeA.click();
            assigneeA.click();
            delete window.assigneeElement;}
        }
      } else {
        localStorage.removeItem(storageKey);
      }
    };

    if (isEasyMDE) {
      let retry = 0;
      const retryTimer = setInterval(() => {
        const editor = textarea.closest('form').querySelector('.CodeMirror-lines');
        if (!editor) {
          if (retry++ > 100) clearInterval(retryTimer);
          return;
        }
        clearInterval(retryTimer);
        editor.addEventListener('mouseleave', () => doSave('mouseleave'));
      }, 50);
    } else {
      textarea.addEventListener('mouseleave', () => doSave('mouseleave'));
    }

    const formFields = Array.from(textarea.closest('form').querySelectorAll('.content div.field'));
    if (formFields.length) {
      for (const formField of formFields.slice(-1)) {
        formField.addEventListener('mouseover', () => doSave('mouseover'));
      }
    }
    const submitField = textarea.closest('form').querySelector('.tw-justify-end');
    if (submitField) {
      submitField.addEventListener('mouseover', () => doSave('mouseover'));
    }

    form.addEventListener('submit', async () => {
      if (textarea.value.trim() === signatureContent.trim()) textarea.value = '';
      if (!isSaved) return;
      isSaved = false;
      localStorage.setItem('last-submitted-draft', getSaveDraftKey(textarea));
      if (window.labelIds) {
        for (const lableData of window.labelIds) {
          await post(window.labelElement.dataset.updateUrl, lableData);
        }
        delete window.labelIds;
      }
      if (window.assigneeIds) {
        for (const assigneeData of window.assigneeIds) {
          await post(window.assigneeElement.dataset.updateUrl, assigneeData);
        }
        delete window.assigneeIds;
      }
    });
  }

  const lastSubmittedDraft = localStorage.getItem('last-submitted-draft');
  if (lastSubmittedDraft) {
    localStorage.removeItem(lastSubmittedDraft);
    localStorage.removeItem('last-submitted-draft');
  }
}

/**
 * Automatically react with "eyes" emoji when a comment comes into view.
 * This uses IntersectionObserver to detect when comment headers are fully visible.
 * It waits 3 seconds before adding the reaction to avoid accidental reactions.
 * It also checks if the reaction already exists to prevent duplicates.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 */
function eyesHandler() {
  const commentList = document.querySelector('.comment-list');
  if (!commentList) return;

  window.addEventListener('scroll', () => {
    window.isProgrammaticScroll = false;
  });

  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting && !window.isProgrammaticScroll) {
        observer.unobserve(entry.target);
        const commentHeader = entry.target.closest('.comment');
        const eyes = commentHeader.querySelector('a.emoji[data-tooltip-content="eyes"]');
        if (eyes) {
          const existEyesReaction = commentHeader.querySelector(`.bottom-reactions a[data-reaction-content=eyes][title*="${window.userTitle}"]`);
          if (existEyesReaction?.title.split(',').map((s) => s.trim()).includes(window.userTitle)) {
            return;
          }
          setTimeout(() => post(`${commentHeader.querySelector('.select-reaction').dataset.actionUrl}/react`, {content: 'eyes'}), 3000);
        }
      }
    }
  }, {
    root: null,
    threshold: 0
  });

  const commentHeaders = commentList.querySelectorAll('.comment-container');
  for (const header of commentHeaders) {
    const lastOfType = header.querySelector('p:last-of-type');
    if (lastOfType) observer.observe(lastOfType);
    else observer.observe(header);
  }
}

async function autoSubscribe() {
  const muteButton = document.querySelector('.octicon-unmute');
  const isMuted = document.querySelector('.octicon-mute');
  const form = isMuted?.closest('form') || muteButton?.closest('form');
  if (muteButton) {
    const assigneeHasSelf = document.querySelector('.relaxed').querySelector(`span[title="${window.loginedUser}"]`);
    if (assigneeHasSelf) {
      const res = await post(form.action, {watch: 1});
      form.innerHTML = await res.text();
      return;
    }
  }
  if (isMuted || muteButton) {
    const watchParam = new URLSearchParams(location.search).get('subscribe');
    if (watchParam) {
      post(form.action, {watch: watchParam})
        .then(response => response.text())
        .then(html => {
          form.innerHTML = html;
        });
    }
  }
}

function handleTextareaInput() {
  autoSaveDraft(); // Hi assignee, auto-labels
  eyesHandler();
  autoSubscribe();
}

/**
 * Wait for the markdown editor to be ready.
 */
function waitForTextareaToBeReady() {
  const textarea = document.querySelector('.combo-markdown-editor textarea');
  if (!textarea) return;
  if (textarea.id === '') {
    const observer = new MutationObserver((mutations) => {
      if (mutations.some(mut => mut.target === textarea.closest('div.combo-markdown-editor'))) {
        observer.disconnect();
        handleTextareaInput();
      }
    });
    observer.observe(document.body, {childList: true, subtree: true});
    return;
  }
  handleTextareaInput();
}

function watchAnnouncementsRepos() {
  const announcementPath = '/ADM/ANN';
  const isAnnouncementPage = window.location.pathname.startsWith(announcementPath);

  if (isAnnouncementPage) {
    const unwatchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/unwatch"] button`);
    const watchFormButtonElement = document.querySelector(`form[action="${announcementPath}/action/watch"] button`);

    if (unwatchFormButtonElement) {
      unwatchFormButtonElement.disabled = true;
    }

    if (watchFormButtonElement) {
      watchFormButtonElement.click();
    }
  }
}

function addCommentCounter() {
  const commentLists = document.querySelectorAll('.comment-list .comment-header-left');
  if (!commentLists) return;

  for (const [index, commentHeader] of commentLists.entries()) {
    if (index === 0) continue; // Skip the first comment (issue description)
    const counterSpan = document.createElement('span');
    counterSpan.className = 'comment-counter';
    counterSpan.textContent = `#${index} `;
    commentHeader.prepend(counterSpan);
  }
}

function relationPRtoIssuesTitle() {
  if (!document.querySelector('.pullrequest-form')) return;
  const comparePos = location.pathname.indexOf('/compare/');
  if (comparePos === -1) return;
  const reposName = location.pathname.substring(1, comparePos);
  if (!reposName) return;
  const branchNameWithID = location.pathname.substring(location.pathname.indexOf('...') + 3, location.pathname.length).replace(/%23/g, '#');
  const branchNameAndRepoAndIDMatch = /^([^_]+)_.*[_]([^_]+\/[^_]+)[_#](\d+)$/.exec(branchNameWithID);
  const branchNameAndIDMatch = /^([^_]+)_.*[_#](\d+)$/.exec(branchNameWithID);
  const issueRepoAndIDMatch = /_([[^_]+])[_#](\d+)$/.exec(branchNameWithID);
  const issueIDOnlyMatch = /[_#](\d+)$/.exec(branchNameWithID);
  const issueTitleInput = document.querySelector('#issue_title');
  const markdownEditor = document.querySelector('.markdown-text-editor');

  const fetchIssueDetails = async (mergeReposName, mergeIssueID) => {
    const issueData = await get(`/api/v1/repos/${mergeReposName}/issues/${mergeIssueID}`);
    if (!issueData) return;
    const gid = reposName === mergeReposName ? `#${mergeIssueID}` : `${mergeReposName}#${mergeIssueID}`;
    issueTitleInput.value = `${issueData.title} ${gid}`;
    markdownEditor.value = markdownEditor.value.replace(/Issue ID:/, `Issue ID: ${gid}`);
    const commitSummary = Array.from(document.querySelectorAll('.commit-summary'), (v) => v.textContent).reverse();
    markdownEditor.value = markdownEditor.value.replace(/Description:\n -/, `Description:\n- ${commitSummary.join('\n - ')}`);
    const labelInput = document.querySelector('input[name=label_ids]');
    const labelElement = labelInput.closest('div');
    for (const label of issueData.labels.map((v) => [v.id, v.name])) {
      if (!['bug', 'important'].includes(label[1].toLowerCase())) continue;
      [...labelElement.querySelectorAll('a .gt-ellipsis')].find(e => e.textContent.trim() === label[1])?.click();
    }
    return true;
  };

  function selectedBranchName(branchName) {
    const branchWithoutRepo = location.pathname.substring(location.pathname.indexOf('/compare/') + 9);
    if (!branchWithoutRepo.startsWith(branchName)) {
      const matchBranch = Array.from(document.querySelectorAll('.base-branch-list a')).find((el) => el.textContent.endsWith(branchName));
      if (matchBranch) {
        const threeDotPos = branchWithoutRepo.indexOf('...');
        location = new URL(location.href.replace(branchWithoutRepo.substring(0, threeDotPos), branchName));
      }
    }
  }

  if (branchNameAndRepoAndIDMatch?.length > 3) {
    selectedBranchName(branchNameAndRepoAndIDMatch[1]);
    if (!fetchIssueDetails(branchNameAndRepoAndIDMatch[2], branchNameAndRepoAndIDMatch[3])) {
      fetchIssueDetails(reposName, branchNameAndRepoAndIDMatch[3]);
    }
  } else if (branchNameAndIDMatch?.length > 2) {
    selectedBranchName(branchNameAndIDMatch[1]);
    fetchIssueDetails(reposName, branchNameAndIDMatch[2]);
  } else if (issueRepoAndIDMatch?.length > 2) {
    fetchIssueDetails(issueRepoAndIDMatch[1], issueRepoAndIDMatch[2]);
  } else if (issueIDOnlyMatch?.length > 1) {
    fetchIssueDetails(reposName, issueIDOnlyMatch[1]);
  }
}

const loadResource = (url, callback) => {
  if (document.querySelector(`script[src="${url}"]`) || document.querySelector(`link[href="${url}"]`)) {
    return;
  }
  const type = url.endsWith('.css') ? 'css' : 'js';
  const element = document.createElement(type === 'css' ? 'link' : 'script');
  if (type === 'css') {
    element.rel = 'stylesheet';
    element.href = url;
  } else {
    element.src = url;
    element.defer = true;
  }

  element.addEventListener('load', () => {
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    callback && callback();
  });

  if (type === 'css') {
    document.head.append(element);
  } else {
    document.body.append(element);
  }
};

function reportGenerator() {
  document.querySelector('.page-content').classList.add('tw-hidden');
  document.querySelector('#report').classList.remove('tw-hidden');

  loadResource('https://cdn.jsdelivr.net/npm/gridjs/dist/theme/mermaid.min.css');

  loadResource('https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js', () => {
    const {createApp} = window.Vue;
    const db = new SimpleDB('reportissue', this.endDate < daysBefore(0) ? 0 : 3600);

    const userSignature = localStorage.getItem('user-signature')?.trim().replace(/\n/g, ' ');

    const columns = [
      {name: '#', data: null,
        formatter: (_, row) => {
            const rows = grid.config.store.state.data.rows;
            const visualIndex = rows.findIndex(r => r.id === row.id);
            return (visualIndex > -1) ? `${visualIndex + 1}.` : "...";
        }, attributes: {style: 'width:52px'}},
      {name: 'Type', sort: true, hidden: true, attributes: {style: 'width:70px'}},
      {name: 'Creator', sort: true, hidden: true, attributes: {style: 'width:190px', class: 'gridjs-td ellipsis'}},
      {name: 'Assignee', sort: {compare: (a, b) => (a ?? '').localeCompare(b ?? '')}, hidden: true, attributes: {style: 'width:190px', class: 'gridjs-td ellipsis'}},
      {name: 'Repos.#ID', sort: {compare: (a, b) => a.props.content.replace(/<[^>]*>?/gm, '').localeCompare(b.props.content.replace(/<[^>]*>?/gm, ''))}, attributes: {style: 'width:150px', class: 'gridjs-td  tw-whitespace-nowrap ellipsis-start'}},
      {name: 'Title', sort: true, attributes: {style: 'width:80%', class: 'gridjs-td tw-whitespace-nowrap ellipsis'}},
      {name: 'Labels', sort: {compare: (a, b) => a.props.content.replace(/<[^>]*>?/gm, '').localeCompare(b.props.content.replace(/<[^>]*>?/gm, ''))}, hidden: true, attributes: {style: 'width:150px', class: 'gridjs-td ellipsis'}},
      {name: 'Status', sort: true, hidden: true, attributes: {style: 'width:80px'}},
      {name: 'Created At', sort: true, hidden: true, attributes: {style: 'width:160px', class: 'gridjs-td ellipsis'}},
      {name: 'Updated At', sort: true, hidden: true, attributes: {style: 'width:160px', class: 'gridjs-td ellipsis'}},
      {name: 'PCT', sort: true, hidden: true, attributes: {style: 'width:70px'}},
      {name: 'Due Date', sort: true, hidden: true, attributes: {style: 'width:160px', class: 'gridjs-td ellipsis'}},
    ];

    function daysBefore(n) {
      const date = new Date();
      date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
      n && date.setDate(date.getDate() - n);
      return date.toISOString().slice(0, 10);
    }

    function commentsToChild() {
      const commToChildBtn = document.querySelector('#comm-to-child');
      const tbody = window.grid.config.container.querySelectorAll('.gridjs-tbody tr');
      const commentsColumn = document.querySelector('[data-column-id="comments"]');
      commentsColumn.classList.toggle('tw-hidden');
      commToChildBtn.textContent = commentsColumn.classList.contains('tw-hidden') ? 'Child to column' : 'Comment to child';
      commentsColumn.classList.contains('tw-hidden') ? localStorage.setItem('report-comment-to-child', 1) : localStorage.removeItem('report-comment-to-child');
      for (const row of tbody) {
        const comment = row.querySelector('td[data-column-id="comments"]');
        const hasSubComment = comment.classList.contains('tw-hidden');
        comment.classList.toggle('tw-hidden');
        if (hasSubComment || row.classList.contains('sub-comment')) {
          const nextSibling = row.nextElementSibling;
          nextSibling?.classList.contains('sub-comment') && nextSibling.classList.toggle('tw-hidden');
          continue;
        }
        const subComment = comment.cloneNode(true);
        subComment.classList.toggle('tw-hidden');
        const newTr = document.createElement('tr');
        newTr.classList.add('sub-comment');
        subComment.colSpan = row.querySelectorAll('td').length - 1;
        subComment.innerHTML = `&nbsp;&nbsp;- ${subComment.innerHTML}`;
        newTr.append(subComment);
        row.after(newTr);
      }
    }

    function addExportButton(endDate) {
      const search = document.querySelector('.gridjs-search');
      if (!search) return;

      const exportBtn = document.createElement('button');
      exportBtn.textContent = 'Export';
      exportBtn.className = 'ui button tw-ml-1';
      search.append(exportBtn);
      exportBtn.addEventListener('click', () => {
        // eslint-disable-next-line no-undef
        const tableExport = new TableExport(document.querySelector('.gridjs-table'), {formats: ['csv'], filename: `report-${endDate}`});
        const csvData = tableExport.getExportData('csv');
        const csvName = Object.keys(csvData).join('');
        const exportData = csvData[csvName]['csv'];
        tableExport.export2file(exportData.data,
          exportData.mimeType,
          exportData.filename,
          exportData.fileExtension,
          exportData.merges,
          exportData.RTL,
          exportData.sheetname);
        document.querySelector('.button-default.csv')?.remove();
      });

      const copyBtn = document.createElement('button');
      copyBtn.textContent = langIsZh ? window.config.i18n.copy_success.slice(0, 2) : 'Copy';
      copyBtn.className = 'ui button';
      search.append(copyBtn);
      copyBtn.addEventListener('click', async () => {
        const tbody = document.querySelector('.gridjs-tbody');
        const plain = Array.from(tbody.rows).map(row =>
            Array.from(row.cells)
              .filter(cell => !cell.classList.contains('tw-hidden'))
              .map(cell => cell.textContent)
              .join(' ')
          ).join('\n');

        const html = document.querySelector('.gridjs-table').cloneNode(true);
        html.querySelectorAll('.tw-hidden').forEach(el => el.remove());

        const item = new ClipboardItem({
          'text/html': new Blob([html.outerHTML], { type: 'text/html' }),
          'text/plain': new Blob([plain], { type: 'text/plain' })
        });

        await copyToClipboard(item);
        copyBtn.setCustomValidity(window.config.i18n.copy_success);
        copyBtn.reportValidity();
      });

      if (document.querySelector('#toggle-column-comments')?.checked) {
        const commToChildBtn = document.createElement('button');
        commToChildBtn.id = 'comm-to-child';
        commToChildBtn.textContent = 'Comment to child';
        commToChildBtn.className = 'ui button';
        search.append(commToChildBtn);
        commToChildBtn.addEventListener('click', async () => commentsToChild());
        const observer = new MutationObserver(() => {
          observer.disconnect();
          localStorage.getItem('report-comment-to-child') && commentsToChild();

          if (document.querySelectorAll('.columns-checkbox:checked').length > 4) {
            const titleColumn = document.querySelector('[data-column-id="title"]');
            if (titleColumn) titleColumn.style.width = '400px';
          }
        });
        observer.observe(document.querySelector('.gridjs-tbody'), {childList: true, subtree: true});
      }

    }

    function titleControl(endDate) {
      const container = document.querySelector('#column-controls');
      container.innerHTML = '';

      for (const column of columns) {
        const name = column.name.toLowerCase();
        if (localStorage.getItem(`report-column-${name}`)) {
          column.hidden = false;
        }
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'tw-align-middle tw-mr-1 columns-checkbox';
        checkbox.id = `toggle-column-${name}`;
        checkbox.checked = !column.hidden;
        checkbox.addEventListener('change', (event) => {
          column.hidden = !event.target.checked;
          if (event.target.checked && !['#', 'repos.#id', 'title'].includes(name)) localStorage.setItem(`report-column-${name}`, 1);
          else localStorage.removeItem(`report-column-${name}`);
          window.grid.updateConfig({
            columns,
          }).forceRender();
          addExportButton(endDate);
        });

        const label = document.createElement('label');
        label.style.whiteSpace = 'nowrap';
        label.className = 'tw-mr-2';
        label.append(checkbox);
        const text = document.createElement('text');
        text.style = 'user-select:none';
        text.textContent = column.name;
        label.append(text);

        container.append(label);
      }
    }

    function cleanCellText(text) {
      return text
        // CRLF → LF
        .replace(/[\r\n]+/g, ' ')

        // Markdown link → text
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')

        // HTML <a> → inner text
        .replace(/<a\b[^>]*>(.*?)<\/a>/gi, '$1')

        // Issue / PR URL → owner/repo#id
        .replace(
          /https?:\/\/[\w\.]+\/([\w-]+)\/([\w-]+)\/(?:issues|pulls)\/(\d+)/g,
          '$1/$2#$3'
        )

        // commit hash to 10 chars
        .replace(
          /https?:\/\/[\w\.]+\/([\w-]+)\/([\w-]+)\/commit\/([a-f0-9]{7,40})/g,
          (_match, p1, p2, p3) => {
            const shortHash = p3.substring(0, 10);
            return `${p1}/${p2}@${shortHash}`;
          }
        )

        // Images → empty
        .replace(/<img[^>]+>/g, '');
    }

    function resetObjToFalse(obj) {
      for (const key in obj) {
        obj[key] = false;
      }
    }

    window.app = createApp({
      delimiters: ['[[', ']]'],
      data() {
        return {
          loading: false,
          orig: localStorage.getItem('report-orig') || '',
          endDateMax: daysBefore(0),
          startDate: daysBefore(7),
          endDate: daysBefore(0),
          quickday: 7,
          by: localStorage.getItem('report-by') || (window.isRD ? 'assigned_by' : 'created_by'),
          type: localStorage.getItem('report-type') || 'all',
          state: localStorage.getItem('report-state') || 'all',
          q: localStorage.getItem('report-q') || '',
          username: localStorage.getItem('report-username') || window.loginedUser,
          userTitle: localStorage.getItem('report-usertitle') || window.userTitle,
          assignees: [],
          okCount: 1,
          isSelected: {},
          isReposOpen: false,
          isLabelsOpen: false,
          isUsersOpen: false,
          reposCounts: {count: 0, open: 0, closed: 0},
          reposSummary: {},
          labelsSummary: {},
          usersSummary: {},
        };
      },
      computed: {
        combined() {
          return [
            this.by,
            this.type,
            this.state
          ];
        }
      },
      watch: {
        combined() {
          this.queryReport();
        },
        startDate(newValue) {
          if (!newValue) return;
          const sDate = new Date(this.startDate).getTime();
          const eDate = new Date(this.endDate).getTime();
          if (eDate - sDate > 15811200000) this.endDate = new Date(sDate + 15811200000).toISOString().slice(0, 10);
          const newDay = new Date(newValue);
          newDay.setDate(newDay.getDate() + this.quickday);
          if (sDate < eDate || newDay.getTime() > Date.now()) return;
          this.endDate = newDay.toISOString().slice(0, 10);
          window.startDateAdjusted = 1;
        },
        endDate(newValue) {
          if (!newValue) return;
          const sDate = new Date(this.startDate).getTime();
          const eDate = new Date(this.endDate).getTime();
          if (eDate - sDate > 15811200000) this.startDate = new Date(eDate - 15811200000).toISOString().slice(0, 10);
          const newDay = new Date(newValue);
          newDay.setDate(newDay.getDate() - this.quickday);
          if (!window.startDateAdjusted && (eDate > sDate || newDay.getTime() < 0)) return;
          this.startDate = newDay.toISOString().slice(0, 10);
        },
        orig(newValue) {
          if (newValue === '') localStorage.removeItem('report-orig');
          else localStorage.setItem('report-orig', newValue);
        },
        by(newValue) {
          if (window.isRD && newValue === 'assigned_by' || !window.isRD && newValue === 'created_by') localStorage.removeItem('report-by');
          else localStorage.setItem('report-by', newValue);
        },
        type(newValue) {
          if (newValue === 'all') localStorage.removeItem('report-type');
          else localStorage.setItem('report-type', newValue);
        },
        state(newValue) {
          if (newValue === 'all') localStorage.removeItem('report-state');
          else localStorage.setItem('report-state', newValue);
        },
        q(newValue) {
          if (newValue === '') localStorage.removeItem('report-q');
          else localStorage.setItem('report-q', newValue);
        },
        userTitle(newValue, oldValue) {
          if (newValue === oldValue) return;
          newValue ? localStorage.setItem('report-usertitle', newValue) : localStorage.removeItem('report-usertitle');
          localStorage.removeItem('report-username');
        }
      },
      methods: {
        dateCtrl(day) {
          this.quickday = day;
          if (day >= 0) {
            this.startDate = daysBefore(day);
            this.queryReport();
            window.startDateAdjusted = 0;
          }
        },
        textColorFor(hex) {
          hex = hex.replace('#', '');

          const r = parseInt(hex.substring(0,2), 16);
          const g = parseInt(hex.substring(2,4), 16);
          const b = parseInt(hex.substring(4,6), 16);

          const luminance = (0.299*r + 0.587*g + 0.114*b);
          return luminance > 186 ? '#000' : '#fff';
        },
        onToggle(target, e) {
          if (target === 'repos') {
            this.isReposOpen = e.target.open;
            this.isReposOpen ? localStorage.setItem('report-repos-details-open', 1) : localStorage.removeItem('report-repos-details-open');
          }
          if (target === 'labels') {
            this.isLabelsOpen = e.target.open;
            this.isLabelsOpen ? localStorage.setItem('report-labels-details-open', 1) : localStorage.removeItem('report-labels-details-open');
          }
          if (target === 'users') {
            this.isUsersOpen = e.target.open;
            this.isUsersOpen ? localStorage.setItem('report-users-details-open', 1) : localStorage.removeItem('report-users-details-open');
          }
        },
        async filterRepos(repo, state, e) {
          const isDeselect = !this.isSelected[`${repo}-open`] && !this.isSelected[`${repo}-closed`];
          !isDeselect && resetObjToFalse(this.isSelected);
          state && (this.isSelected[`${repo}-open`] = isDeselect);
          !state && (this.isSelected[`${repo}-closed`] = isDeselect);
          let newData;
          if (repo === null) {
            newData = !isDeselect ? window.originalData : window.grid.config.data.filter(row => state ? row[6] === 'open' : row[6] === 'closed');
          } else {
            newData = !isDeselect ? window.originalData : e.altKey ? window.grid.config.data.filter(row => !row[3].props.content.replace(/<[^>]+>/g, '').includes(`${repo}#`)) : window.grid.config.data.filter(row => row[3].props.content.replace(/<[^>]+>/g, '').includes(`${repo}#`) && row[6] === (state ? 'open' : 'closed'));
          }
          window.grid.updateConfig({
            data: newData,
          }).forceRender();
          addExportButton(this.endDate);
          await this.$nextTick();
          if (isDeselect && e.altKey) {
            e.target.classList.remove('tw-text-white');
            e.target.classList.add('term-fg9', 'tw-text-danger');
          }
        },
        async filterLabel(label, e) {
          const isDeselect = !this.isSelected[label];
          !isDeselect && resetObjToFalse(this.isSelected);
          this.isSelected[label] = isDeselect;
          const newData = !isDeselect ? window.originalData : window.grid.config.data.filter(row => e.altKey ? !row[5].props.content.includes(`"${label}"`) : row[5].props.content.includes(`"${label}"`));
          window.grid.updateConfig({
            data: newData,
          }).forceRender();
          addExportButton(this.endDate);
          await this.$nextTick();
          isDeselect && e.altKey && e.target.classList.add('term-fg9', 'tw-text-danger');
        },
        async filterUser(createdUser, assignedUser, e) {
          const isDeselect = !this.isSelected[`${createdUser}-created`] && !this.isSelected[`${assignedUser}-assigned`];
          !isDeselect && resetObjToFalse(this.isSelected);
          createdUser && (this.isSelected[`${createdUser}-created`] = isDeselect);
          assignedUser && (this.isSelected[`${assignedUser}-assigned`] = isDeselect);
          const newData = !isDeselect ? window.originalData : window.grid.config.data.filter(row => createdUser && e.altKey ? !row[1].includes(createdUser) : row[1].includes(createdUser) || assignedUser && e.altKey ? !row[2]?.includes(assignedUser) : row[2]?.includes(assignedUser));
          window.grid.updateConfig({
            data: newData,
          }).forceRender();
          addExportButton(this.endDate);
          await this.$nextTick();
          isDeselect && e.altKey && e.target.classList.add('term-fg9', 'tw-text-danger');
        },
        submit() {
          this.okCount++;
          this.queryReport(1);
        },
        selectedUser() {
          const filterUsernameItem = Array.from(document.querySelectorAll('#report .filter .item')).find((el) => el.textContent === this.userTitle);
          filterUsernameItem?.classList.add('selected');
          const observer = new IntersectionObserver(() => {
            observer.disconnect();
            filterUsernameItem?.scrollIntoView({inline: 'center', block: 'center'});
          });
          observer.observe(document.querySelector('#report .filter.menu'));
        },
        async queryReport(isNotOKButton) {
          const maxCommentLength = 100;

          if (this.okCount > 10) {
            db.clear();
            this.okCount = 1;
          }

          if (!isNotOKButton) this.okCount = 1;

          setCursor('wait');
          if (this.loading) return;
          this.loading = true;

          this.isSelected = {};
          this.reposCounts = {count: 0, open: 0, closed: 0};
          const reposSummaryData = {};
          this.reposSummary = {};

          const labelsSummaryData = {};
          this.labelsSummary = {};

          const usersSummaryData = {};
          this.usersSummary = {};

          const startDate = `${this.startDate}T00:00:00Z`;
          const startDateTime = new Date(startDate).getTime();
          const endDate = `${this.endDate}T23:59:59Z`;
          const endDateTime = new Date(endDate).getTime();

          const isSelf = this.userTitle === window.userTitle;
          const params = new URLSearchParams();
          params.set('state', this.state);
          params.set('since', startDate);
          params.set('before', endDate);
          params.set('page', 1);
          params.set('limit', 10000);
          if (this.by === 'created_by') params.set('by_created', 'true');

          if (this.orig) params.set('owner', this.orig);
          if (this.q) params.set('q', this.q);
          if (isSelf) {
            if (this.by === 'assigned_by') {
              params.set('assigned', 'true');
            } else if (this.by === 'created_by') {
              params.set('created', 'true');
            }
          }

          let resData = await db.get(params.toString());
          let commData = [];

          if (!resData) {
            const indexKey = params.toString();
            resData = await get(`/api/v1/repos/issues/search?${indexKey}`);
            db.set(indexKey, resData);
          }

          const startUnixTime = Math.floor(startDateTime / 1000);
          const endUnixTime = Math.floor(endDateTime / 1000);
          let heatmapData = await db.get(`heatmap-${startUnixTime}-${endUnixTime}`);
          if (!heatmapData) {
            // /api/v1/users/heatmap?start=1765828800&end=1768420800
            heatmapData = await get(`/api/v1/users/heatmap?start=${startUnixTime}&end=${endUnixTime}&limit=1000`);
            heatmapData = Object.fromEntries(heatmapData.map(x => [x.full_name, x.contributions]));
            db.set(`heatmap-${startUnixTime}-${endUnixTime}`, heatmapData);
          }

          const commentsColumn = columns.find((v) => v.name === 'Comments');
          if (this.by === 'myself') {
            const reposLists = [];
            for (const issue of resData || []) {
              const repoName = issue.repository.full_name;
              if (!reposLists.includes(repoName)) {
                reposLists.push(repoName);
              }
            }

            const commParams = new URLSearchParams();
            commParams.set('since', startDate);
            commParams.set('before', endDate);
            commParams.set('page', 1);
            commParams.set('limit', 10000);
            const commParamsKey = commParams.toString();
            for (const repo of reposLists) {
              const commIndexKey = `${repo}_${commParamsKey}`;
              let cachedData = await db.get(commIndexKey);
              if (!cachedData) {
                // /api/v1/repos/TestOrg/TestRepo/issues/comments?since=2026-01-15T00%3A00%3A00Z&before=2026-01-22T23%3A59%3A59Z&limit=10000
                cachedData = await get(`/api/v1/repos/${repo}/issues/comments?${commParamsKey}`);
                db.set(commIndexKey, cachedData);
              }
              cachedData.length && commData.push(...cachedData);
            }
            commData = commData.filter((v) => v.user.full_name.startsWith(this.userTitle));

            if (!commentsColumn) {
              columns.push({
                name: 'Comments',
                sort: true, hidden: true,
                attributes: {style: 'width: 200px', class: 'gridjs-td ellipsis'},
              });
            }
          } else if (commentsColumn) {
            columns.splice(columns.indexOf(commentsColumn), 1);
          }

          titleControl(this.endDate);

          function usersSummary(usersSummaryData, onlyName, assigneeNames, heatmapData) {
            if (onlyName) {
              usersSummaryData[onlyName.full_name] = usersSummaryData[onlyName.full_name] || {created: 0, assigned: 0, contributed: heatmapData[onlyName.full_name] || 0, username: onlyName.username};
              usersSummaryData[onlyName.full_name].created++;
            }
            for (const assignee of assigneeNames) {
              usersSummaryData[assignee.full_name] = usersSummaryData[assignee.full_name] || {created: 0, assigned: 0, contributed: heatmapData[assignee.full_name] || 0, username: assignee.username};
              usersSummaryData[assignee.full_name].assigned++;
            }
          }

          const data = [];
          const assigneeLists = [];
          for (const issue of resData || []) {
            if (this.by === 'assigned_by' && issue.assignees) {
              for (const assignee of issue.assignees) {
                assigneeLists.push({username: assignee.username, full_name: assignee.full_name, avatar_url: assignee.avatar_url});
              }
            } else if (this.by === 'created_by') {
              assigneeLists.push({username: issue.user.username, full_name: issue.user.full_name, avatar_url: issue.user.avatar_url});
              const createdAt = new Date(issue.created_at).getTime();
              if (createdAt < startDateTime || createdAt > endDateTime) {
                continue;
              }
            } else {
              assigneeLists.push({username: issue.user.username, full_name: issue.user.full_name, avatar_url: issue.user.avatar_url});
            }
            if ((this.userTitle.length && (this.by === 'assigned_by' && !issue.assignees?.some((a) => a.full_name.startsWith(this.userTitle))) ||
              (this.userTitle.length && this.by === 'created_by' && !issue.user.full_name.startsWith(this.userTitle)) ||
              (this.userTitle.length && this.by === 'mentioned_by' && !issue.body.includes(`@${this.username}`))) ||
              (this.type !== 'all' && this.type !== (issue.pull_request ? 'pr' : 'issue')) ||
              (this.state !== 'all' && this.state !== issue.state) ||
              (this.userTitle.length && this.by === 'myself' && commData.find((c) => c.user.full_name.startsWith(this.userTitle) && issue.html_url === c.issue_url) === undefined)) {
              continue;
            }

            const repoName = issue.repository.full_name;
            this.isSelected[repoName] = false;
            reposSummaryData[repoName] = reposSummaryData[repoName] || {open: 0, closed: 0};

            const labels = issue.labels.map((l) => {return {name: l.name, color: l.color}});
            let label = '';
            for (let j = 0; j < labels.length; j++) {
              // eslint-disable-next-line github/unescaped-html-literal
              label += `<span style="background-color:#${labels[j].color};color:${this.textColorFor(labels[j].color)};" class="ui label" data-tooltip-content="${labels[j].name}">${labels[j].name}</span> `;
              this.isSelected[labels[j].name] = false;
              labelsSummaryData[labels[j].name] = {color: `#${labels[j].color}`, count: labelsSummaryData[labels[j].name] ? labelsSummaryData[labels[j].name].count + 1 : 1};
            }

            const onlyName = issue.user.full_name;
            const assigneeNames = issue.assignees?.map((a) => ({full_name: a.full_name, username: a.username})) || [];

            const checkedTasks = issue.body.match(/- \[x\] /g)?.length || 0;
            const totalTasks = checkedTasks + (issue.body.match(/- \[ \] /g)?.length || 0);
            const pct = totalTasks > 0 ? Math.round(checkedTasks / totalTasks * 100) : 0;

            const issueID = `<a href="${issue.html_url}" data-tooltip-content="${repoName}#${issue.number}" target="_blank" rel="noopener">${repoName}#${issue.number}</a>`;

            // eslint-disable-next-line no-undef
            data.push([issue.pull_request ? 'PR' : 'Issues', onlyName, issue.assignees?.map((a) => a.full_name).join(', '), gridjs.html(issueID), issue.title, gridjs.html(label), issue.state, issue.created_at.slice(0, 19).replace('T', ' '), issue.updated_at.slice(0, 19).replace('T', ' '), `${pct}%`, issue.due_date ? issue.due_date.slice(0, 10) : '']);
            if (commData.length) {
              const commentsMatchingIssue = commData.filter(comment => {
                const commentTime = new Date(comment.created_at).getTime();
                return comment.issue_url === issue.html_url && commentTime >= startDateTime && commentTime <= endDateTime && comment.user.full_name.startsWith(this.userTitle);
              });

              if (commentsMatchingIssue.length > 0) {

                onlyName && (this.isSelected[onlyName] = false);

                usersSummary(usersSummaryData, {full_name: onlyName, username: issue.user.username}, assigneeNames, heatmapData, issue.user.username);

                const lastComment = commentsMatchingIssue[commentsMatchingIssue.length - 1];
                const lastCommentBody = cleanCellText(lastComment.body.slice(0, maxCommentLength));
                const commentSignatureIndex = lastCommentBody.lastIndexOf(userSignature);
                const commentText = lastCommentBody.slice(0, commentSignatureIndex === -1 ? maxCommentLength : commentSignatureIndex);
                data[data.length - 1].push(commentText.trim() + (lastComment.body.length > maxCommentLength ? '...' : ''));
                issue.state === 'open' ? reposSummaryData[repoName].open++ : reposSummaryData[repoName].closed++;
              } else {

                const lastLabelsContent = data[data.length - 1][5].props.content;
                const doc = new DOMParser().parseFromString(lastLabelsContent, "text/html");
                const lastLabels = [...doc.querySelectorAll('span')].map(el => el.textContent);
                for (const label of Object.keys(labelsSummaryData)) {
                  lastLabels.includes(label) && labelsSummaryData[label].count--;
                  if (labelsSummaryData[label].count < 1) {
                    delete this.isSelected[label];
                    delete labelsSummaryData[label];
                  }
                }
                data.pop();
              }
            } else {
              onlyName && (this.isSelected[onlyName] = false);
              usersSummary(usersSummaryData, {full_name: onlyName, username: issue.user.username}, assigneeNames, heatmapData, issue.user.username);
              issue.state === 'open' ? reposSummaryData[repoName].open++ : reposSummaryData[repoName].closed++;
            }
          }
          this.assignees = Array.from(new Map(assigneeLists.map((a) => [a.full_name, a])).values()).sort((a, b) => a.full_name.localeCompare(b.full_name));

          window.originalData = data;
          window.grid.updateConfig({
            data
          }).forceRender();

          addExportButton(this.endDate);

          this.reposSummary = Object.fromEntries(Object.entries(reposSummaryData).sort((a, b) => b[1].count - a[1].count));
          for (const [_, repoData] of Object.entries(reposSummaryData)) {
            this.reposCounts = {count: this.reposCounts.count + repoData.open + repoData.closed, open: this.reposCounts.open + repoData.open, closed: this.reposCounts.closed + repoData.closed};
          }
          this.labelsSummary = Object.fromEntries(Object.entries(labelsSummaryData).sort((a, b) => b[1].count - a[1].count));
          if (this.by === 'assigned_by') this.usersSummary = Object.fromEntries(Object.entries(usersSummaryData).sort((a, b) => b[1].assigned - a[1].assigned));
          else if (this.by === 'created_by') this.usersSummary = Object.fromEntries(Object.entries(usersSummaryData).sort((a, b) => b[1].created - a[1].created));
          else this.usersSummary = Object.fromEntries(Object.entries(usersSummaryData).sort((a, b) => b[1].contributed - a[1].contributed));

          this.loading = false;
          setCursor('');

        },
        selectAssignee(assignee, username, e) {
          if (!e.isTrusted) return;
          this.userTitle = assignee;
          this.username = username;
          this.queryReport();
          localStorage.setItem('report-username', username);
        },
      },
      mounted() {

        document.querySelector('.item.active')?.classList.toggle('active')
        document.querySelector('a[href="#report"]').classList.toggle('active');

        loadResource('https://cdn.jsdelivr.net/npm/gridjs/dist/gridjs.umd.js', async () => {

          // eslint-disable-next-line no-undef
          window.grid = new gridjs.Grid({
            columns,
            data: [],
            search: true
          });

          window.grid.on('cellClick', (cell) => {
            const target = cell.target.closest('td');
            if (!target) return;
            if (target.textContent.match(/[\w-]+\/[\w-]+#\d+/)) target.classList.toggle('ellipsis-start');
            else target.classList.toggle('ellipsis');
            target.classList.toggle('overflow-x-auto');
          });

          window.grid.render(document.querySelector('#wrapper'));

          this.isReposOpen = localStorage.getItem('report-repos-details-open');
          this.isLabelsOpen = localStorage.getItem('report-labels-details-open');
          this.isUsersOpen = localStorage.getItem('report-users-details-open');

          window.app.queryReport();

        });
      },
    }).mount('#report');
    window.Vue = null;
  });
  loadResource('https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js');
  loadResource('https://cdn.jsdelivr.net/npm/tableexport/dist/js/tableexport.min.js');
}

function addReleaseFilterBar() {
  const newReleases = document.querySelector('.new.release form:not(.secondary-nav form)');
  const db = new SimpleDB('releases', 86400);
  if (newReleases) {
    newReleases.addEventListener('submit', async () => {
      await db.remove(location.pathname.substring(1, location.pathname.indexOf('/releases')));
    });
    return;
  }
  const wrapper = document.querySelector('#release-list');
  if (!wrapper) return;
  const filterBar = document.querySelector('#releaseFilterBar');
  filterBar.classList.remove('tw-hidden');
  wrapper.insertBefore(filterBar, wrapper.children[0]);
  loadResource('https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js', () => {
    const {createApp} = window.Vue;
    createApp({
      delimiters: ['[[', ']]'],
      data() {
        return {
          releaselists: [],
        };
      },
      methods: {
        async queryRelease() {
          const reposName = location.pathname.substring(1, location.pathname.indexOf('/releases'));
          let data = await db.get(reposName);
          if (data && data.length && data[0].name !== document.querySelector('.release-list-title a').textContent) {
            data = null;
          }
          if (!data || !data.length) {
            data = await get(`/api/v1/repos/${reposName}/releases?limit=1000`);
            db.set(reposName, data);
          }
          this.releaselists = data.map((v) => {return {name: v.name, html_url: v.html_url}});
        },
        selectRelease(html_url) {
          location = new URL(html_url);
        },
      },
      mounted() {
        this.queryRelease();
      }
    }).mount('#releaseFilterBar');
    window.Vue = null;
  });
}

function addPageControlBarToTop() {
  const pageControlElement = document.querySelector('.page');
  if (pageControlElement) {
    const issueListElement = document.querySelector('#issue-list') || document.querySelector('#activity-feed');
    if (issueListElement) {
      const newCloseButton = document.createElement('a');
      newCloseButton.className = 'close-btn';
      newCloseButton.addEventListener('click', () => {
        document.querySelector('.top-pagination').remove();
        localStorage.removeItem('top-pagination');
      });
      const topControlElement = pageControlElement.cloneNode(true);
      topControlElement.classList.add('top-pagination');
      topControlElement.querySelector('.menu').append(newCloseButton);
      issueListElement.parentNode.insertBefore(topControlElement, issueListElement);
      localStorage.setItem('top-pagination', 1);
    }
  }
}

function addPageControlButton() {
  if (localStorage.getItem('top-pagination') === 'true') {
    addPageControlBarToTop();
    return;
  }

  const pageControlElement = document.querySelector('.page');
  if (pageControlElement) {
    const topControlButton = document.createElement('a');
    topControlButton.className = 'top-control-button btn tiny';
    topControlButton.textContent = 'Add Page Bar to Top';
    topControlButton.addEventListener('click', () => {
      if (document.querySelector('.top-pagination')) return;
      addPageControlBarToTop();
      topControlButton.classList.add('tw-hidden');
    });
    const wrapper = document.createElement('div');
    wrapper.className = 'center tw-mt-4';
    wrapper.append(topControlButton);
    pageControlElement.parentNode.appendChild(wrapper, pageControlElement);
  }
}

function addViewLogsButton() {
  const first = document.querySelector('.first');
  if (!first) return;
  const events = document.querySelectorAll('.event');
  if (!events) return;
  const hideLogs = localStorage.getItem('hide-logs');
  if (hideLogs) {
    for (const el of events) el.classList.toggle('tw-hidden');
  }
  const viewLogButton = document.createElement('button');
  viewLogButton.className = 'ui button tiny tw-mt-1 tw-ml-1';
  viewLogButton.style.minHeight = 'unset';
  viewLogButton.textContent = (hideLogs ? '+' : '-') + ` Logs (${events.length})`;
  viewLogButton.disabled = !events.length;
  viewLogButton.addEventListener('click', () => {
    const hideLogs = localStorage.getItem('hide-logs');
    hideLogs ? localStorage.removeItem('hide-logs') : localStorage.setItem('hide-logs', 1);
    viewLogButton.textContent = (hideLogs ? '-' : '+') + ` Logs (${events.length})`;
    for (const el of events) el.classList.toggle('tw-hidden');
  });
  first.append(viewLogButton);
}

function addRelatedButton() {
  const first = document.querySelector('.first');
  if (!first) return;
  const related = document.querySelectorAll('.octicon-bookmark');
  if (!related) return;

  const viewRelatedButton = document.createElement('button');
  viewRelatedButton.className = 'ui button tiny tw-mt-1';
  viewRelatedButton.style.minHeight = 'unset';
  viewRelatedButton.textContent = `⤒ Related (${related.length})`;
  viewRelatedButton.disabled = !related.length;
  viewRelatedButton.addEventListener('click', () => {
    const topRelatedElements = document.querySelectorAll('.top-related');
    for (const el of topRelatedElements) el.closest('div').classList.add('tw-hidden');

    if (topRelatedElements.length) {
      viewRelatedButton.textContent =   `⤒ Related (${related.length})`;
      for (const el of topRelatedElements) el.closest('div').remove();
      return;
    } else {
      viewRelatedButton.textContent = `⤓ Related (${related.length})`;
    }

    const relatedItems = Array.from(related).reverse();
    for (const el of relatedItems) {
      const parentElement = el.closest('div').cloneNode(true);
      parentElement.classList.remove('tw-hidden');
      parentElement.classList.add('top-related');
      first.insertAdjacentElement('afterend', parentElement);
    }
  });
  first.append(viewRelatedButton);
}

function addReverseButton() {
  const firstElement = document.querySelector('.first');
  if (!firstElement) return;

  const timelineElement = document.querySelector('.timeline');
  if (!timelineElement) return;

  const reverseButtonElement = document.createElement('button');
  reverseButtonElement.className = 'ui button tiny tw-mt-1';
  reverseButtonElement.style.minHeight = 'unset';
  reverseButtonElement.textContent = '▼ Reverse';
  reverseButtonElement.disabled = !timelineElement.querySelectorAll('.comment:not(.first,.form)').length;
  const toggleReverse = () => {
    const isReversed = timelineElement.classList.toggle('timeline-reverse');
    if (isReversed) {
      localStorage.setItem('timeline-reverse', 1);
    } else {
      localStorage.removeItem('timeline-reverse');
    }
    reverseButtonElement.textContent = isReversed ? '▲ Obverse' : '▼ Reverse';
  };

  reverseButtonElement.addEventListener('click', toggleReverse);

  firstElement.append(reverseButtonElement);

  if (localStorage.getItem('timeline-reverse') === '1') toggleReverse();
}

function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      if (typeof text === 'string') navigator.clipboard.writeText(text);
      else navigator.clipboard.write([text]);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      // eslint-disable-next-line unicorn/prefer-dom-node-append
      document.body.appendChild(textarea);
      textarea.select();
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      document.execCommand('copy');
      textarea.remove();
    }
    return true;
  } catch {}
}

function addCopyTitleButton() {
  const titleButton = document.querySelector('.issue-title-buttons');
  if (!titleButton) return;
  const copyTitleButton = document.createElement('button');
  copyTitleButton.className = 'ui button tiny';
  copyTitleButton.style.minHeight = 'unset';
  copyTitleButton.textContent = langIsZh ? window.config.i18n.copy_success.slice(0, 2) : 'Copy';
  copyTitleButton.addEventListener('click', () => {
    const id = document.querySelector('.issue-content-right .octicon-copy').closest('button').dataset.clipboardText;
    const title = document.querySelector('.issue-title h1').textContent.trim().split('\n')[0];
    copyTitleButton.setCustomValidity(copyToClipboard(new ClipboardItem({'text/html': new Blob([`<a href="${window.location.href}">${id}</a>\t${escapeHtml(title)}`], {type: 'text/html'}), 'text/plain': new Blob([`${id}\t${title}`], {type: 'text/plain'})})) ? window.config.i18n.copy_success : window.config.i18n.copy_error);
    copyTitleButton.reportValidity();
  });
  titleButton.prepend(copyTitleButton);
}

function addCopyIssuesTitleButton() {
  const toolBar = document.querySelector('#issue-actions .issue-list-toolbar-right .menu');
  if (!toolBar) return;

  if (!document.querySelector('.copy-title-list')) {
    const copyTitleButton = document.createElement('button');
    copyTitleButton.className = 'ui button tiny issue-action copy-title-list';
    copyTitleButton.textContent = langIsZh ? window.config.i18n.copy_success.slice(0, 2) : 'Copy';
    copyTitleButton.addEventListener('click', () => {
      const selectedIssuesLists = document.querySelectorAll('.issue-checkbox:checked');
      const fullTitleLists = [];
      const htmlItems = [];
      let i = 1;
      for (const el of selectedIssuesLists) {
        const titleElement = el.closest('div.flex-item').querySelector('.flex-item-title').querySelector('a');
        const href = titleElement.getAttribute('href');
        const id = href.slice(1).replace('/issues/', '#');
        const title = titleElement.textContent.trim();
        fullTitleLists.push(`${i}.\t${id}\t${title}`);
        htmlItems.push(`${i++}. <a href="${href}">${id}</a>\t${escapeHtml(title)}`);
      }

      const data = new ClipboardItem({'text/html': new Blob([htmlItems.join('<br>\n')], {type: 'text/html'}), 'text/plain': new Blob([fullTitleLists.join('\n')], {type: 'text/plain'})});

      if (fullTitleLists.length) copyToClipboard(data);
    });
    toolBar.prepend(copyTitleButton);
  }
}

function addCommitsCheckBox() {
  const wrapper = document.querySelectorAll('.message-wrapper');
  if (!wrapper) return;
  for (const el of wrapper) {
    const title = el.querySelector('.commit-summary')?.title;
    if (!title) break;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.dataset.tooltipContent = 'Select to copy issue titles (Shift+Click to select all)';
    checkbox.className = 'issue-checkbox tw-align-middle';
    checkbox.value = title.replace(/(#\d+) \(#\d+\)$/, '$1');
    checkbox.addEventListener('click', (e) => {
      if (e.shiftKey) {
        const checkboxes = document.querySelectorAll('.issue-checkbox');
        for (const cb of checkboxes) {
          cb.checked = cb !== e.currentTarget ? !cb.checked : true;
        }
      }
      const selectedCommits = document.querySelectorAll('.issue-checkbox:checked');
      const fullTitleLists = [];
      for (const el of selectedCommits) {
        fullTitleLists.push(`- [ ] ${el.value}`);
      }

      if (fullTitleLists.length) copyToClipboard(fullTitleLists.join('\n'));
    });
    el.prepend(checkbox);
  }
}

function addRevisionNumber() {
  const commitSummary = document.querySelector('.octicon-history');
  if (!commitSummary) return;
  const urlSearchParams = new URLSearchParams(location.search);
  let revision = commitSummary.closest('a').querySelector('b')?.textContent.replace(/,/, '') - (urlSearchParams.get('page') ? (urlSearchParams.get('page') - 1) * 50 : 0);
  const branchName = document.querySelector('.branch-dropdown-button')?.textContent.trim();
  const commitIDElemtns = document.querySelectorAll('.commit-id-short');
  for (const el of commitIDElemtns) {
    if (revision &&document.querySelector('[name=q]').value.trim() === "") el.prepend(`r${revision--} `);
    const copyBtn = document.createElement('button');
    copyBtn.className = 'btn tw-pr-1 tw-align-middle';
    copyBtn.dataset.clipboardText = `${branchName} ${el.textContent}`;
    copyBtn.innerHTML = '<svg viewBox="0 0 16 16" class="svg octicon-copy" aria-hidden="true" width="14" height="14"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
    el.parentElement.prepend(copyBtn);
  }
}

function notificationToSystem() {
  const NOTIFY_INTERVAL = 300_000;
  const STORAGE_KEY = 'notificationed';

  if (!('Notification' in window)) {
    console.warn('Browser does not support notifications.');
  } else {
    (async () => {
      const permission = await Notification.requestPermission();
      if (permission !== 'granted') return;

      const channel = new BroadcastChannel('logout-notify');
      let notificationTimer = null;

      const fetchNotifications = async () => {
        try {
          const url = new URL('/api/v1/notifications', location.origin);
          url.search = new URLSearchParams({
            'status-types': 'unread',
            limit: 10,
            _csrf: window.config.csrfToken,
          });

          const response = await get(url);
          if (!response) return;

          const notificationCount = document.querySelector('.notification_count');
          if (notificationCount) {
            notificationCount.textContent = response.length;
            notificationCount.classList.remove('tw-hidden');
          }

          const lastNotified = localStorage.getItem(STORAGE_KEY);

          for (const data of Array.from(response).reverse()) {
            if (!lastNotified || data.updated_at > lastNotified) {
              localStorage.setItem(STORAGE_KEY, data.updated_at);

              const n = new Notification(
                `${data.repository.full_name}#${data.subject.html_url.split('/').pop()} ${data.subject.state}`,
                {
                  icon: `${window.config.appUrl}assets/img/favicon.png`,
                  body: data.subject.title,
                  tag: `Gitea${data.id}`,
                },
              );

              n.onclick = (e) => {
                e.preventDefault();
                window.open(
                  data.subject.latest_comment_html_url || data.subject.html_url,
                  '_blank',
                );
              };
            }
          }
        } catch (err) {
          console.error('Fetch notification failed:', err);
          clearInterval(notificationTimer);
          notificationTimer = null;
        }
      };

      const start = () => {
        channel.postMessage(null);
        if (!notificationTimer) {
          notificationTimer = setInterval(fetchNotifications, NOTIFY_INTERVAL);
        }
      };

      channel.onmessage = () => {
        clearInterval(notificationTimer);
        notificationTimer = null;
      };

      window.addEventListener('focus', start);

      start();
    })();
  }
}

function parseSizeToBytes(str) {
  const m = str.trim().match(/^([\d.]+)\s*(B|KiB|MiB|GiB|KB|MB|GB)$/i);
  if (!m) return NaN;

  const value = parseFloat(m[1]);
  const unit = m[2].toUpperCase();

  const map = {
    B: 1,
    KIB: 1024,
    MIB: 1024 ** 2,
    GIB: 1024 ** 3,
    KB: 1000,
    MB: 1000 ** 2,
    GB: 1000 ** 3,
  };

  return value * (map[unit] ?? 1);
}

function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function toYMD(d) {
  return `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
}

async function autoRemoveFiles() {
  const skipKey = `skip-auto-remove${location.pathname}`;
  const isPRMerged = document.querySelector('.issue-title-meta .octicon-git-merge');
  if (!isPRMerged && (sessionStorage.getItem(skipKey) || !Array.from(document.querySelectorAll('.list.labels-list a')).some((el) => el.textContent.toLowerCase() === 'solved'))) return;
  const lists = [];

  const userComments = document.querySelectorAll(`.comment:not(.form) a[href^="/${window.loginedUser}"].timeline-avatar`);
  for (const el of userComments) {
    const commentElement = el.closest('div.comment');
    const updateDataSet = commentElement.querySelector('.edit-content-zone').dataset;
    if (updateDataSet) {
      const attachmentsElements = commentElement.querySelectorAll('.dropzone-attachments div.tw-flex-1 a strong');
      const attachmentsSizes = Array.from(commentElement.querySelectorAll('.dropzone-attachments div.tw-flex .text')).map((el) => parseSizeToBytes(el.textContent));
      let html;
      for (const attachEl of attachmentsElements) {
        const fileSize = attachmentsSizes.shift();
        if (fileSize < 10485760) continue; // skip less than 10MB
        const fullName = attachEl.textContent;
        const fileName = fullName.slice(0, fullName.lastIndexOf('.'));
        const commentID = updateDataSet.updateUrl.split('/').pop();
        const rawContent = document.querySelector(`#issuecomment-${commentID}-raw`);
        if (!rawContent) continue;
        const contentElement =  rawContent.parentElement.querySelector('.render-content');
        rawContent.textContent = rawContent.textContent.replace(new RegExp(`\\[${escapeRegExp(fileName)}[^\\]]*\\]\\([^)]*\\)`, 'g'), `~~Auto remove [${fullName}]~~`);
        html = html || contentElement.innerHTML;
        html = html.replace(new RegExp(`<a .*${escapeRegExp(fileName)}[^<]*</a>`, 'g'), `<del>Auto remove [${fullName}]</del>`);
        lists.push({
          name: fileName,
          updateDataSet: updateDataSet,
          attach: attachEl,
          text: rawContent.textContent,
          html: html,
        });
      }
    }
  }

  let doDel = true;
  if (lists.length && (isPRMerged || (doDel = confirm(`Are you sure to auto remove ${lists.length} file${lists.length > 1 ? 's' : ''}?\n\n${lists.map((list) => list.name).join('\n')}`)))) {
    for (const list of lists) {
      const commentID = list.updateDataSet.updateUrl.split('/').pop();
      const rawContent = document.querySelector(`#issuecomment-${commentID}-raw`);
      const contentElement =  rawContent.parentElement.querySelector('.render-content');
      await post(list.updateDataSet.updateUrl, {content: list.text, context: list.updateDataSet.context, content_version: list.updateDataSet.contentVersion++}).then(response => {
        if (response.ok) {
          list.attach.closest('div.tw-flex').remove();
          contentElement.innerHTML = list.html;
        }
      });
    }
  }
  if (!doDel) {
    sessionStorage.setItem(skipKey, '1');
  }
}

function addStickyToNavBar() {
  const navBar = document.querySelector('#navbar');
  if (!navBar) return;
  navBar.classList.add('sticky');
}

function addIssuesCheckBox() {
  if (!location.pathname.includes('/milestone') && !['/issues', '/pulls'].some((path) => location.pathname === path)) return;
  const wrapper = document.querySelectorAll('#issue-list .flex-item-main');

  for (const el of wrapper) {
    const index = el.querySelector('.flex-item-body a.index')?.textContent.trim();
    const title = el.querySelector('.flex-item-title a')?.textContent;
    if (!title) break;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.dataset.tooltipContent = 'Select to copy issue titles (Shift+Click to select all)';
    checkbox.className = 'issue-checkbox tw-mr-2 tw-align-middle';
    checkbox.value = index;
    checkbox.dataset.title = title.replace(/(#\d+) \(#\d+\)$/, '$1');
    checkbox.dataset.link = el.querySelector('a').href;
    checkbox.addEventListener('click', (e) => {
      if (e.shiftKey) {
        const checkboxes = document.querySelectorAll('.issue-checkbox');
        for (const cb of checkboxes) {
          cb.checked = cb !== e.currentTarget ? !cb.checked : true;
        }
      }
      const selectedCommits = document.querySelectorAll('.issue-checkbox:checked');
      const fullTitleLists = [];
      const htmlItems = [];
      let i = 1;
      for (const el of selectedCommits) {
        fullTitleLists.push(`${i}.\t${el.value}\t${el.dataset.title}`);
        htmlItems.push(`${i++}. <a href="${el.dataset.link}">${el.value}</a>\t${el.dataset.title}`);
      }
      if (fullTitleLists.length) {
        const data = new ClipboardItem({'text/html': new Blob([htmlItems.join('<br>\n')], {type: 'text/html'}), 'text/plain': new Blob([fullTitleLists.join('\n')], {type: 'text/plain'})});
        copyToClipboard(data);
      }
    });
    el.querySelector('.flex-item-title a').prepend(checkbox);
  }
}

function excludeSolvedIssues() {
  if (!window.isRD) return;
  const issueLink = document.querySelector('.navbar-left a[href="/issues?type=assigned"]');
  issueLink.href = issueLink.href.replace('assigned', 'assigned&q=-label:Solved%20-label:Feedback');
}

function addCopySelfActivitesButton() {
  if (location.pathname !== '/' || (location.pathname !== '/' && location.search !== '?tab=activity')) return;
  const activity = document.querySelector('#activity-feed');
  if (!activity) return;

  const button = document.createElement('button');
  button.textContent = langIsZh ? window.config.i18n.copy_success.slice(0, 2) : 'Copy';
  button.className = 'ui button tiny';
  button.addEventListener('click', () => {
    const items = activity.querySelectorAll('.flex-item-main');
    const fullTitleLists = [];
    const htmlItems = [];
    let i = 1;
    for (const el of items) {
      const idElement = el.querySelector('a:nth-child(2)');
      const title = el.querySelector('a.title')?.textContent;
      const id = idElement.textContent;
      const text = `${i}.\t${id}\t${title}`;
      if (!id || !title || fullTitleLists.includes(text)) continue;
      fullTitleLists.push(text);
      htmlItems.push(`${i++}. <a href="${idElement.href}">${id}</a>\t${escapeHtml(title)}`);
    }
    const data = new ClipboardItem({'text/html': new Blob([htmlItems.join('<br>\n')], {type: 'text/html'}), 'text/plain': new Blob([fullTitleLists.join('\n')], {type: 'text/plain'})});
    if (fullTitleLists.length) button.setCustomValidity(copyToClipboard(data) ? window.config.i18n.copy_success : window.config.i18n.copy_error);
    button.reportValidity();
  });
  activity.prepend(button);
}

/**
 * Wait for the DOM to be ready.
 */
document.addEventListener('DOMContentLoaded', () => {
  window.userTitle = document.querySelector('.avatar').title;
  window.dept = window.userTitle.substring(0, window.userTitle.indexOf(' '));
  window.isRD = window.dept.startsWith('RD');
  window.loginedUser = document.querySelector('#navbar .user-menu .header strong')?.textContent;
  window.langIsZh = document.querySelector('.language-menu a.selected').lang.startsWith('zh');

  controlButtonsVisibility();
  waitForTextareaToBeReady();
  watchAnnouncementsRepos();
  addCommentCounter();
  relationPRtoIssuesTitle();
  if (location.hash === '#report') {
    reportGenerator();
  }
  if (location.pathname.includes('/releases')) {
    addReleaseFilterBar();
  }

  addPageControlButton();
  addViewLogsButton();
  addRelatedButton();
  addReverseButton();
  addCopyTitleButton();
  addCopyIssuesTitleButton();
  addCommitsCheckBox();
  addRevisionNumber();
  notificationToSystem();
  autoRemoveFiles();
  addStickyToNavBar();
  addIssuesCheckBox();
  excludeSolvedIssues();
  addCopySelfActivitesButton();
});
